<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Tide Documentation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css" rel="stylesheet">
    <link href="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap-theme.min.css" rel="stylesheet">
    <link rel="stylesheet" href="http://yandex.st/highlightjs/8.0/styles/default.min.css">
    <script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>

    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>

    <div class="container">
      <h1>Introduction</h1>
<p><a href="https://github.com/tide-framework/tide">Tide</a> is a web framework that allows 
seemless communication between <a href="http://amber-lang.net">Amber</a> and 
<a href="http://pharo-project.org">Pharo</a>. </p>
<p>Tide exposes information using the <code>JSON</code> format. The <code>JSON</code> is built from 
Pharo objects and sent through the netword to Amber. The <code>JSON</code> contains data 
exposed from objects in Pharo, but can also contain callback information 
to perform actions from Amber to Pharo objects. Having both data and actions 
sent to Amber makes Tide a very good communication protocol between the two 
Smalltalks.</p>
<p>To make communication as natural as possible, the Amber layer of Tide uses 
promises to keep the flow of callback calls sequential.</p>
<p>This documentation aims to teach how to install and use Tide through examples, 
as well as its architecture.</p>
<h1> Installing Tide</h1>
<h2>1.  Prerequisites</h2>
<p>Tide requires several libraries. It of course depends on Pharo and Amber. Amber
itself requires <code>nodejs</code> and <code>bower</code> to install its own dependencies. The 
Pharo-side of Tide requires Zinc, which is part of the default image since 
Pharo 2.0. Tide however has only been tested with Pharo 3.0.</p>
<h3>1.1.  NodeJs</h3>
<p>Go to <a href="http://nodejs.org">nodejs.org</a> and install <code>node</code> (and <code>npm</code>) for your
platform.</p>
<h3>1.2.  Bower</h3>
<p>Bower is a package manager for the web, and Amber uses Bower to manage 
dependencies. The simplest way to use bower is to install it globally as 
follows:</p>
<p><figure><pre><code>$ npm install -g bower</code></pre><figcaption></figcaption></figure></p>
<h3>1.3.  Pharo</h3>
<p>Tide requires Pharo 3.0. The simplest way to install it is to evaluate the 
following:</p>
<p><figure><pre><code>$ curl get.pharo.org/30+vm | bash</code></pre><figcaption></figcaption></figure></p>
<p>To start the Pharo image, evaluate:</p>
<p><figure><pre><code>$ ./pharo-ui Pharo.image</code></pre><figcaption></figcaption></figure></p>
<h4>1.3.1.  Preparing the Pharo image</h4>
<p>Once you get the Pharo window open, you have to install the Tide backend part. 
This means bringing the Pharo code you cloned from GitHub into the Pharo image.</p>
<ul><li> Click on the background of the Pharo window</li><li> In the World menu that appears, click on <code>Workspace</code></li><li> In that window, evaluate: (you type the thing, select the text and then right </li></ul><p>  click and select &quot;Do It&quot; from the menu).</p>
<p><figure><pre><code>Metacello new
  configuration: 'Tide';
  version: #development;
  repository: 'http://www.smalltalkhub.com/mc/Pharo/MetaRepoForPharo30/main';
  load.</code></pre><figcaption></figcaption></figure></p>
<p>When this is finished, evaluate:</p>
<p><figure><pre><code>TDDispatcher tideIndexPageUrl inspect</code></pre><figcaption></figcaption></figure></p>
<p>When first executed, you will get an error saying you must execute bower 
install in a particular directory. Open a terminal, change to the right 
directory, and execute:</p>
<p><figure><pre><code>$ bower install</code></pre><figcaption></figcaption></figure></p>
<p>Back in the Pharo window, close the error message and evaluate the same instruction 
again:</p>
<p><figure><pre><code>TDDispatcher tideIndexPageUrl inspect</code></pre><figcaption></figcaption></figure></p>
<p>This should give you the URL at which your web browser should be pointed to. 
Now copy this URL, open your web browser and paste it in the browser's address bar.</p>


<h3>1.4.  Starting the server</h3>
<p>The <code>TDServer</code> class provides a convenient way to start/stop a Tide server, using
Zinc behind the scenes:</p>
<p><figure><pre><code>TDServer startOn: 5000. &quot;Start the server on port 5000&quot;
TDServer stop. &quot;Stop any running server&quot;</code></pre><figcaption></figcaption></figure></p>
<h1> A first example: the traditional counter</h1>
<p>In order to get started with Tide, we will implement the traditional counter example.</p>
<p>Tide already includes such an example in the <code>Tide-Examples</code> package that you can 
refer to.</p>
<h2>2.  The presenter</h2>
<p>A counter application should contain two buttons, one to increase and the other one to
decrease a count. It should also display the count value to the user.</p>
<p>While this application might seem extremely simplistic, it already shows some of the 
core principles behing Tide: Presenters and Proxies.</p>
<p>We start by creating the <code>MyCounter</code> class in Pharo by subclassing <code>TDPResenter</code>.</p>
<p><figure><pre><code>TDPresenter subclass: #MyCounter
	instanceVariableNames: 'count'
	classVariableNames: ''
	category: 'MyCounter'</code></pre><figcaption></figcaption></figure></p>
<p>Note that not all &quot;exposed&quot; objects have to be subclasses of <code>TDPresenter</code>. As we will
see later, any object can be exposed to Amber using a <code>TDModelPresenter</code> instance
on the domain object.</p>
<p>Our class has one instance variable <code>count</code>, that we initialize to <code>0</code>:</p>
<p><figure><pre><code>MyCounter &gt;&gt; initialize
    count := 0</code></pre><figcaption></figcaption></figure></p>
<p>To display the count value to the user, we will need to expose <code>count</code> using an accessor.
We also add two methods to increase and decrease our counter:</p>
<p><figure><pre><code>MyCounter &gt;&gt; count
    ^ count

MyCounter &gt;&gt; increase
    count := count + 1

MyCounter &gt;&gt; decrease
    count := count - 1</code></pre><figcaption></figcaption></figure></p>
<p>The final step we need to add the our counter is pragmas. Pragmas are 
metadata on methods. Tide uses pragmas to expose data (called state in Tide) 
and callbacks (called actions) to Amber. Here's our final version of the 
counter class:</p>
<p><figure><pre><code>MyCounter &gt;&gt; count
    &lt;state&gt;
    ^ count

MyCounter &gt;&gt; increase
    &lt;action&gt;
    count := count + 1

MyCounter &gt;&gt; increase
    &lt;action&gt;
    count := count - 1</code></pre><figcaption></figcaption></figure></p>
<h2>3.  Registering applications with handlers</h2>
<p>We now have to create an entry point with our counter presenter in the Tide server.
To register the entry point, evaluate:</p>
<p><figure><pre><code>MyCounter registerAt: 'my-counter'.</code></pre><figcaption></figcaption></figure></p>
<p>We can deduce two points from the preceding evaluation:</p>
<ul><li> Presenter classes are registered as handlers, not instances. Tide will create &quot;per session&quot; instances of the registered class meaning that presenters are not share between user sessions.</li><li> The entry point will have a <code>handler</code> associated with a fixed entry point  url <code>'/my-counter'</code>. When someone will query that registered url, the presenter will generate <code>JSON</code> data corresponding to its state and actions, and the handler to send it back in a response to the request.</li></ul>
<p>If we perform a request at <code>http://localhost:5000/my-counter</code>, we get the following 
<code>JSON</code> data back:</p>
<p><figure><pre><code>{
  &quot;__id__&quot;:&quot;bwv8m74bhgzmv0dgvzptuy4py&quot;,
  &quot;actions&quot;:{
    &quot;increase&quot;:&quot;/my-counter?_callback=359446426&quot;,
    &quot;decrease&quot;:&quot;/my-counter?_callback=523483752&quot;
  },
  &quot;state&quot;:{
    &quot;count&quot;:0
  }
}</code></pre><figcaption></figcaption></figure></p>
<h2>4.  The Amber application</h2>
<p>The next step in our example is to create the Amber-side of this counter application.
We will use Amber to render an HTML view of our counter, and perform actions using proxies
back to the counter defined in Pharo.</p>
<h3>4.1.  The client-side API</h3>
<p>On the client-side, root presenters exposed as handler can be accessed by creating proxies:</p>
<p><figure><pre><code>myProxy := TDClientProxy on: '/my-counter'.</code></pre><figcaption></figcaption></figure></p>
<p>Message sent to proxies will be resolved using its <strong>state</strong> and <strong>actions+</strong> as defined on 
the server-side.</p>
<p>Calls to state methods are resolved locally and synchronously, because the state is passed
over to Amber as we previously say in the JSON data.</p>
<p>Calls to action methods perform requests that will result in performing the corresponding
method on the pharo object asynchronously. Once the action is performed, the proxy will
be automatically updated with possible new state and actions.</p>
<p>Since action calls are not synchronous, Tide proxies have a special method <code>then:</code> used
to perform actions only when and if the action is resolved and the proxy updated.</p>
<p><figure><pre><code>&quot;synchronous state call&quot;
myProxy count. &quot;=&gt; 0&quot;

&quot;async action call&quot;
myProxy increase; then: [
    myProxy count &quot;=&gt; 1&quot; ]</code></pre><figcaption></figcaption></figure></p>
<h3>4.2.  The widget class</h3>
<p>In Amber's IDE, create a new class <code>MyCounterWidget</code>. </p>
<p><figure><pre><code>Widget subclass: #MyCounterWidget
	instanceVariableNames: 'counter header'
	package: 'Tide-Amber-Examples'</code></pre><figcaption></figcaption></figure></p>
<p>The widget class has two instance variables: <code>counter</code>, which is hold a proxy over the 
Pharo counter object, and <code>header</code> which will hold a reference on the header tag brush to
update the UI.</p>
<p>To initialize our counter widget, we connect it to the Pharo counter presenter as follows:</p>
<p><figure><pre><code>initialize
    super initialize.
    counter := TDClientProxy on: '/my-counter'</code></pre><figcaption></figcaption></figure></p>
<p>Note that <code>'/my-counter'</code> is the path to the server-side handler for our counter presenter.</p>
<p>We can now create the rendering methods.</p>
<p><figure><pre><code>render
    counter connect then: [
        self appendToJQuery: 'body' asJQuery ]


renderOn: html
	header := html h1 with: counter count asString.
	html button 
		with: '++';
		onClick: [ self increase ].
	html button 
		with: '--';
		onClick: [ self decrease ]

update
	header contents: [ :html |
		html with: counter count asString ]</code></pre><figcaption></figcaption></figure></p>
<p>The <code>render</code> method waits for the counter to be connected, then appends the widget to the
<code>body</code> element of the page (using the <code>renderOn:</code> method).</p>
<p><code>renderOn:</code> is a typical widget rendering method using the builtin Amber <code>HTMLCanvas</code>.
The <code>count</code> message send to the <code>counter</code> proxy will be resolved as a state accessor as
defined on the server-side.</p>
<p>Finally instead of updating the entire HTML contents of the counter, <code>update</code> will only 
update the relevant part, the header.</p>
<p>We still miss two methods to actually increase and decrease our counter:</p>
<p><figure><pre><code>increase
	self counter increase.
	self counter then: [ self update ]

decrease
	self counter decrease.
	self counter then: [ self update ]</code></pre><figcaption></figcaption></figure></p>
<p><figure><img src="images/tide-counter.png"></img><figcaption></figcaption></figure></p>
<h1> More on actions</h1>
<h1> Managing sessions</h1>
<h1> Handlers</h1>
<p class="todo">should it be there already? It seems too early to talk about that, but I need to introduce the concept in order to talk about the file upload handler.</p>
<h1> Creating custom Presenters</h1>
<h1> Managing file uploads</h1>
<p>Managing file uploads in the context of a flat-client application can be cumbersome. 
The reason is that file uploads with the HTTP protocols were not made for asynchronous 
uploads. Tide tries to solve this problem by abstracting away the implementation details 
of an AJAX-friendly file upload with the <code>TDFileHandler</code> class.</p>
<h2>5.  Creating file upload entry points</h2>

<h1> Handling exceptions</h1>
<h1> A more advanced example: &lt;&lt;FIND SOMETHING&gt;&gt;</h1>

    </div>

    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
